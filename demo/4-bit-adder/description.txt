本算法只能算任意两个四位二进制数的加法，其和可以高至五位（被加数需要一个前导0）。
图灵机初始位置在纸带末尾。

为方便区分加数中的0和1和被加数中的0和1，一开始需将加数的0和1替换为a和b。
然后检查加数中的每一位，若为a（即0）则状态码+1并向左移动，否则将b改为a，状态码+10，进入被加数被加状态。
由于状态码的个位与被加位对应，所以越过加号后每移动一位状态码-1，直到减为10时，即给所在位+1，若要进位则将该位设为0，然后左行。
若加数全为a，进入停机状态。

照此原理，可以类推五位、六位、乃至一百位的加法器，不过状态数会变多，故到了更高位的时候，我们又会需要一个全新的算法指令集，此处仅做演示。

----------------

q255: 初始化阶段，将加数的0和1分别换为a和b
q0: 一次加法结束，返回到最右位
q1-4: 检查加数第一至四位
q11-14: 发现第一至四位为正，越过加号后每左行一位递减一
q10: 被加数所在位取反；若为负转至q0，否则向左
q100: 所有指令执行完毕，停机

----------------

指令集：

state x w h next

q255 B B L q255
q255 0 a L q255
q255 1 b L q255
q255 + + R q0

q0 0 0 R q0
q0 1 1 R q0
q0 + + R q0
q0 a a R q0
q0 b b R q0
q0 B B L q1

q1 a a L q2
q1 b a L q11
q2 a a L q3
q2 b a L q12
q3 a a L q4
q3 b a L q13
q4 a a L q100
q4 b a L q14

q11 a a L q11
q11 b b L q11
q11 + + L q10
q12 a a L q12
q12 b b L q12
q12 + + L q11
q13 a a L q13
q13 b b L q13
q13 + + L q12
q14 + + L q13

q10 0 1 R q0
q10 1 0 L q10

q11 0 0 L q10
q11 1 1 L q10
q12 0 0 L q11
q12 1 1 L q11
q13 0 0 L q12
q13 1 1 L q12

q100 + + N q100
